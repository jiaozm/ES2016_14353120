# Lab4:死锁­Deadlock
需要用到Java，本次实验不需要用到ubuntu
***
## 实验理解：
1、死锁就是两个或者多个进程，互相请求对方占有的资源。在操作系统课上有学习过。而本次实验就是用java来模拟死锁的发生过程。加深对于死锁的理解。
2、死锁产生的四个条件：
	1.互斥条件：一个资源每次只能被一个进程使用
	2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
	3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
	4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系


## 实验过程
#### 1、编写java文件并编译，ppt上有相关代码：
![](https://raw.githubusercontent.com/jiaozm/ES2016_14353120/master/lab4_pic/1.png) <p>
编译后：
![](https://raw.githubusercontent.com/jiaozm/ES2016_14353120/master/lab4_pic/2.png) <p>
#### 2、分析该代码：
该文件中主要处理Deadlock类（继承于Runnable），即是一个线程。而又声明了A、B类方便调用。在Deadlock类构造函数当中，还声明了一个Thread对象的线程，当调用了t.start()函数的时候，这个线程就会加入到调用队列当中去；当被调用时，开始跑run函数里面的内容。而count是用来模拟耗时处理的。
3、按照要求生成了bat文件后，运行结果为：
![](https://raw.githubusercontent.com/jiaozm/ES2016_14353120/master/lab4_pic/3.png) <p>
可知在第84次的时候停止了，说明产生了死锁。分析过程为在Runnable类中，main函数开始运行的时候就生成了一个Deadlock对象，在其声明的时候就会调用其构造函数，并在其内部实现了一个Thread 对象。开始的时候该对象就被添加到了调度队列当中，等待系统分配资源。与此同时，主线程Deadlock也在进行等待。当两者等待时间一样的时候，同时会调用这两句话：
a.methodA(b);
b.methodB(a);
即是如果两个函数同时调用，a本身要使用方法，同时却又要作为参数传递给b，对b
来说也是如此，这就造成了一个死循环，形成了死锁。


## 实验感想：
  本次实验复习了过去在操作系统当中学习的死锁相关的知识。同时也让我回忆起以前的解决办法，如设置临界区等等。而这次实验则是通过一个java程序来加深对于死锁的理解。让我获益匪浅。



